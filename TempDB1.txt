use crate::state::AppState;
use crate::types::{Button, PasswordItem, RecipientKey, CustomField};
use crate::encryption::{encrypt, decrypt};
use tauri::State;
use sqlx::Row;
use sqlx::SqlitePool;
use chrono::Utc;
use zeroize::Zeroizing;
use validator::Validate;
use serde_json;

pub fn validate_password_item_fields(item: &PasswordItem) -> Result<(), validator::ValidationError> {
    if item.title.is_empty() {
        return Err(validator::ValidationError::new("title_empty"));
    }
    if item.title.len() > 255 {
        return Err(validator::ValidationError::new("title_too_long"));
    }

    if let Some(username) = &item.username {
        if username.is_empty() {
            return Err(validator::ValidationError::new("username_empty"));
        }
    }

    // Allow placeholder password "N/A" for entries created without a real password
    if item.password != "N/A" {
        if item.password.is_empty() {
            return Err(validator::ValidationError::new("password_empty"));
        }
        if item.password.len() < 8 {
            return Err(validator::ValidationError::new("password_too_short"));
        }
    }

    if let Some(url) = &item.url {
        if !url.is_empty() && !url.starts_with("http://") && !url.starts_with("https://") {
            return Err(validator::ValidationError::new("invalid_url_format"));
        }
    }

    if let Some(totp_secret) = &item.totp_secret {
        if !totp_secret.is_empty() && totp_secret.len() < 16 {
            return Err(validator::ValidationError::new("totp_secret_too_short"));
        }
    }

    Ok(())
}

async fn get_key(state: &State<'_, AppState>) -> Result<Zeroizing<Vec<u8>>, String> {
    let guard = state.key.lock().await;
    let opt = guard.clone();
    drop(guard);
    opt.ok_or_else(|| "Vault is locked".to_string())
}

async fn get_db_pool(state: &State<'_, AppState>) -> Result<SqlitePool, String> {
    let guard = state.db.lock().await;
    guard.clone().ok_or_else(|| "Database not loaded".to_string())
}

#[tauri::command]
pub async fn save_button(
    state: State<'_, AppState>,
    text: String,
    icon: String,
    color: String,
) -> Result<(), String> {
    let key = get_key(&state).await?;
    let db_pool = get_db_pool(&state).await?;

    let text_enc = encrypt(&text, key.as_slice())?;
    let icon_enc = encrypt(&icon, key.as_slice())?;
    let color_enc = encrypt(&color, key.as_slice())?;

    sqlx::query("INSERT INTO buttons (text, icon, color) VALUES (?, ?, ?)")
        .bind(text_enc)
        .bind(icon_enc)
        .bind(color_enc)
        .execute(&db_pool)
        .await
        .map_err(|e| e.to_string())?;
    Ok(())
}

#[tauri::command]
pub async fn get_buttons(state: State<'_, AppState>) -> Result<Vec<Button>, String> {
    let key = get_key(&state).await?;
    let db_pool = get_db_pool(&state).await?;
    let rows = sqlx::query("SELECT id, text, icon, color FROM buttons")
        .fetch_all(&db_pool)
        .await
        .map_err(|e| e.to_string())?;

    let mut buttons = Vec::new();
    for row in rows {
        let text_enc: String = row.get("text");
        let icon_enc: String = row.get("icon");
        let color_enc: String = row.get("color");

        buttons.push(Button {
            id: row.get("id"),
            text: decrypt(&text_enc, key.as_slice())?,
            icon: decrypt(&icon_enc, key.as_slice())?,
            color: decrypt(&color_enc, key.as_slice())?,
        });
    }

    Ok(buttons)
}

#[tauri::command]
pub async fn update_button(
    state: State<'_, AppState>,
    id: i64,
    text: String,
    icon: String,
    color: String,
) -> Result<(), String> {
    let key = get_key(&state).await?;
    let db_pool = get_db_pool(&state).await?;

    let text_enc = encrypt(&text, key.as_slice())?;
    let icon_enc = encrypt(&icon, key.as_slice())?;
    let color_enc = encrypt(&color, key.as_slice())?;

    sqlx::query("UPDATE buttons SET text = ?, icon = ?, color = ? WHERE id = ?")
        .bind(text_enc)
        .bind(icon_enc)
        .bind(color_enc)
        .bind(id)
        .execute(&db_pool)
        .await
        .map_err(|e| e.to_string())?;
    Ok(())
}

#[tauri::command]
pub async fn delete_button(state: State<'_, AppState>, id: i64) -> Result<(), String> {
    get_key(&state).await?;
    let db_pool = get_db_pool(&state).await?;
    sqlx::query("DELETE FROM buttons WHERE id = ?")
        .bind(id)
        .execute(&db_pool)
        .await
        .map_err(|e| e.to_string())?;
    Ok(())
}

#[tauri::command]
pub async fn save_password_item(
    state: State<'_, AppState>,
    item: PasswordItem,
) -> Result<(), String> {
    item.validate().map_err(|e| e.to_string())?;

    let key = get_key(&state).await?;
    let now = Utc::now().to_rfc3339();

    let title_enc = encrypt(&item.title, key.as_slice())?;
    let description_enc = item.description.map(|d| encrypt(&d, key.as_slice())).transpose()?;
    let img_enc = item.img.map(|i| encrypt(&i, key.as_slice())).transpose()?;
    let tags_enc = item.tags.map(|t| encrypt(&t, key.as_slice())).transpose()?;
    let username_enc = item.username.map(|u| encrypt(&u, key.as_slice())).transpose()?;
    let url_enc = item.url.map(|u| encrypt(&u, key.as_slice())).transpose()?;
    let notes_enc = item.notes.map(|n| encrypt(&n, key.as_slice())).transpose()?;
    let password_enc = encrypt(&item.password, key.as_slice())?;
    let totp_secret_enc = item.totp_secret.map(|t| encrypt(&t, key.as_slice())).transpose()?;
    let custom_fields_json = serde_json::to_string(&item.custom_fields).map_err(|e| e.to_string())?;
    let custom_fields_enc = encrypt(&custom_fields_json, key.as_slice())?;
    let field_order_json = item.field_order.map(|fo| serde_json::to_string(&fo)).transpose().map_err(|e| e.to_string())?;
    let field_order_enc = field_order_json.map(|fo_json| encrypt(&fo_json, key.as_slice())).transpose()?;

    let db_pool = get_db_pool(&state).await?;
    sqlx::query("INSERT INTO password_items (title, description, img, tags, username, url, notes, password, created_at, updated_at, color, totp_secret, custom_fields, field_order) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)")
        .bind(title_enc)
        .bind(description_enc)
        .bind(img_enc)
        .bind(tags_enc)
        .bind(username_enc)
        .bind(url_enc)
        .bind(notes_enc)
        .bind(password_enc)
        .bind(now.clone())
        .bind(now)
        .bind(item.color)
        .bind(totp_secret_enc)
        .bind(custom_fields_enc)
        .bind(field_order_enc)
        .execute(&db_pool)
        .await
        .map_err(|e| e.to_string())?;
    Ok(())
}

#[tauri::command]
pub async fn get_password_items(state: State<'_, AppState>) -> Result<Vec<PasswordItem>, String> {
    let key = get_key(&state).await?;
    let db_pool = get_db_pool(&state).await?;
    let rows = sqlx::query("SELECT id, title, description, img, tags, username, url, notes, password, created_at, updated_at, color, totp_secret, custom_fields, field_order FROM password_items")
        .fetch_all(&db_pool)
        .await
        .map_err(|e| e.to_string())?;

    let mut items = Vec::new();
    for row in rows {
        let title_enc: String = row.get("title");
        let title = decrypt(&title_enc, key.as_slice())?;

        let description_enc: Option<String> = row.get("description");
        let description = description_enc.map(|d| decrypt(d.as_str(), key.as_slice())).transpose()?;

        let img_enc: Option<String> = row.get("img");
        let img = img_enc.map(|i| decrypt(i.as_str(), key.as_slice())).transpose()?;

        let tags_enc: Option<String> = row.get("tags");
        let tags = tags_enc.map(|t| decrypt(t.as_str(), key.as_slice())).transpose()?;

        let username_enc: Option<String> = row.get("username");
        let username = username_enc.map(|u| decrypt(u.as_str(), key.as_slice())).transpose()?;

        let url_enc: Option<String> = row.get("url");
        let url = url_enc.map(|u| decrypt(u.as_str(), key.as_slice())).transpose()?;

        let notes_enc: Option<String> = row.get("notes");
        let notes = notes_enc.map(|n| decrypt(n.as_str(), key.as_slice())).transpose()?;

        let password_enc: String = row.get("password");
        let password = decrypt(&password_enc, key.as_slice())?;

        let totp_secret_enc: Option<String> = row.get("totp_secret");
        let totp_secret = totp_secret_enc.map(|t| decrypt(t.as_str(), key.as_slice())).transpose()?;

        let custom_fields_enc: Option<String> = row.get("custom_fields");
        let custom_fields = custom_fields_enc.map(|cf| decrypt(cf.as_str(), key.as_slice())).transpose()?.map(|cf| serde_json::from_str(&cf).unwrap_or_else(|_| vec![])).unwrap_or_else(|| vec![]);

        let field_order_enc: Option<String> = row.get("field_order");
        let field_order = field_order_enc.and_then(|fo_enc| decrypt(fo_enc.as_str(), key.as_slice()).ok()).and_then(|fo_json| serde_json::from_str(&fo_json).ok());


        items.push(PasswordItem {
            id: row.get("id"),
            title,
            description,
            img,
            tags,
            username,
            url,
            notes,
            password,
            created_at: row.get("created_at"),
            updated_at: row.get("updated_at"),
            color: row.get("color"),
            totp_secret,
            custom_fields,
            field_order,
        });
    }

    Ok(items)
}

#[tauri::command]
pub async fn update_password_item_tags(state: State<'_, AppState>, id: i64, tags: String) -> Result<(), String> {
    let key = get_key(&state).await?;
    let now = Utc::now().to_rfc3339();
    // Treat empty or whitespace-only string as clearing tags (NULL in DB)
    let tags_enc_opt: Option<String> = if tags.trim().is_empty() {
        None
    } else {
        Some(encrypt(&tags, key.as_slice())?)
    };
    let db_pool = get_db_pool(&state).await?;
    sqlx::query("UPDATE password_items SET tags = ?, updated_at = ? WHERE id = ?")
        .bind(tags_enc_opt)
        .bind(now)
        .bind(id)
        .execute(&db_pool)
        .await
        .map_err(|e| e.to_string())?;
    Ok(())
}

#[tauri::command]
pub async fn update_password_item_totp_secret(state: State<'_, AppState>, id: i64, totp_secret: String) -> Result<(), String> {
    let key = get_key(&state).await?;
    let now = Utc::now().to_rfc3339();
    let totp_secret_enc = encrypt(&totp_secret, key.as_slice())?;
    let db_pool = get_db_pool(&state).await?;
    sqlx::query("UPDATE password_items SET totp_secret = ?, updated_at = ? WHERE id = ?")
        .bind(totp_secret_enc)
        .bind(now)
        .bind(id)
        .execute(&db_pool)
        .await
        .map_err(|e| e.to_string())?;
    Ok(())
}

#[tauri::command]
pub async fn update_password_item(
    state: State<'_, AppState>,
    item: PasswordItem,
) -> Result<(), String> {
    item.validate().map_err(|e| e.to_string())?;

    let key = get_key(&state).await?;
    let now = Utc::now().to_rfc3339();

    let title_enc = encrypt(&item.title, key.as_slice())?;
    let description_enc = item.description.map(|d| encrypt(&d, &key)).transpose()?;
    let img_enc = item.img.map(|i| encrypt(&i, &key)).transpose()?;
    let tags_enc = item.tags.map(|t| encrypt(&t, &key)).transpose()?;
    let username_enc = item.username.map(|u| encrypt(&u, &key)).transpose()?;
    let url_enc = item.url.map(|u| encrypt(&u, &key)).transpose()?;
    let notes_enc = item.notes.map(|n| encrypt(&n, &key)).transpose()?;
    let password_enc = encrypt(&item.password, key.as_slice())?;
    let totp_secret_enc = item.totp_secret.map(|t| encrypt(&t, key.as_slice())).transpose()?;
    let custom_fields_json = serde_json::to_string(&item.custom_fields).map_err(|e| e.to_string())?;
    let custom_fields_enc = encrypt(&custom_fields_json, key.as_slice())?;

    let field_order_json = item.field_order.map(|fo| serde_json::to_string(&fo)).transpose().map_err(|e| e.to_string())?;
    let field_order_enc = field_order_json.map(|fo_json| encrypt(&fo_json, key.as_slice())).transpose()?;


    let db_pool = get_db_pool(&state).await?;
    sqlx::query("UPDATE password_items SET title = ?, description = ?, img = ?, tags = ?, username = ?, url = ?, notes = ?, password = ?, updated_at = ?, color = ?, totp_secret = ?, custom_fields = ?, field_order = ? WHERE id = ?")
        .bind(title_enc)
        .bind(description_enc)
        .bind(img_enc)
        .bind(tags_enc)
        .bind(username_enc)
        .bind(url_enc)
        .bind(notes_enc)
        .bind(password_enc)
        .bind(now)
        .bind(item.color)
        .bind(totp_secret_enc)
        .bind(custom_fields_enc)
        .bind(field_order_enc)
        .bind(item.id)
        .execute(&db_pool)
        .await
        .map_err(|e| e.to_string())?;
    Ok(())
}

#[tauri::command]
pub async fn add_custom_field(
    state: State<'_, AppState>,
    item_id: i64,
    field_name: String,
    field_type: String,
) -> Result<(), String> {
    let key = get_key(&state).await?;
    let db_pool = get_db_pool(&state).await?;

    let row = sqlx::query("SELECT custom_fields FROM password_items WHERE id = ?")
        .bind(item_id)
        .fetch_one(&db_pool)
        .await
        .map_err(|e| e.to_string())?;

    let custom_fields_enc: Option<String> = row.get("custom_fields");
    let custom_fields_json = custom_fields_enc
        .map(|cf| decrypt(cf.as_str(), key.as_slice()))
        .transpose()?
        .unwrap_or_else(|| "[]".to_string());

    let mut custom_fields: Vec<CustomField> = serde_json::from_str(&custom_fields_json)
        .map_err(|e| e.to_string())?;

    custom_fields.push(CustomField {
        name: field_name,
        value: "".to_string(),
        field_type,
    });

    let updated_custom_fields_json = serde_json::to_string(&custom_fields)
