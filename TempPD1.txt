<script lang="ts">
	import type { PasswordItem } from '../../../routes/+layout.ts';
	import Icon from '../ui/Icon.svelte';
	import { iconPaths } from '$lib/icons';
	import { invoke } from '@tauri-apps/api/core';
	
	import Input from '../ui/Input.svelte';
	import { createEventDispatcher, tick } from 'svelte';
	
	
	import UnsavedChangesPopup from '../UnsavedChangesPopup.svelte';
	import PasswordDetailHeader from '../password/PasswordDetailHeader.svelte';

	// import { SvelteMap } from 'svelte/collections';
    import { flip } from 'svelte/animate';
    import { dndzone } from 'svelte-dnd-action';
    import { cubicOut } from 'svelte/easing';

	const dispatch = createEventDispatcher();

	export let selectedPasswordItem: PasswordItem | null;
	export let displayColor: string;
	export let buttons: any[];

	
	let isEditing = false;
	let hasUnsavedChanges = false;
	let showTimestamps = false;
	let showPassword = false;
	let addingField = false;
	let newFieldType = 'text';
	let newFieldName = '';
    let pendingTagOrder: string | null = null;

	let dndItems: any[] = [];

	$: displayFields = (() => {
		if (!selectedPasswordItem) return [];

		const staticFields = [
			{
				id: 'username',
				name: 'Username',
				value: selectedPasswordItem.username,
				type: 'text',
				icon: iconPaths.user
			},
			{
				id: 'password',
				name: 'Password',
				value: selectedPasswordItem.password,
				type: 'password',
				icon: iconPaths.key
			},
			{ id: 'url', name: 'URL', value: selectedPasswordItem.url, type: 'text', icon: iconPaths.link },
			{
				id: 'notes',
				name: 'Notes',
				value: selectedPasswordItem.notes,
				type: 'multiline',
				icon: iconPaths.notes
			}
		];

		const customFields = (selectedPasswordItem.custom_fields || []).map((f) => ({
			...f,
			id: f.name,
			name: f.name,
			value: f.value,
			type: f.field_type,
			icon: iconPaths.plus
		}));

		let allFields = [...staticFields, ...customFields];

		if (selectedPasswordItem.field_order && selectedPasswordItem.field_order.length > 0) {
			const orderedFields: any[] = [];
			const fieldMap = new Map(allFields.map((field) => [field.id, field]));

			for (const fieldId of selectedPasswordItem.field_order) {
				if (fieldMap.has(fieldId)) {
					orderedFields.push(fieldMap.get(fieldId));
					fieldMap.delete(fieldId);
				}
			}
			for (const remainingField of fieldMap.values()) {
				orderedFields.push(remainingField);
			}
			return orderedFields;
		} else {
			return allFields;
		}
	})();

	

	function handleDndConsider(e: CustomEvent) {
		dndItems = e.detail.items;
	}

	function handleDndFinalize(e: CustomEvent) {
		dndItems = e.detail.items;
		dndItems = [...dndItems];
		if (selectedPasswordItem) {
			selectedPasswordItem.field_order = dndItems.map((item) => item.id);
		}
	}

	

	

	let originalPasswordItem: PasswordItem | null = null;

	$: {
		if (isEditing && originalPasswordItem) {
		const currentItemState = JSON.parse(JSON.stringify(originalPasswordItem));
			const newCustomFields: { name: string; value: string; field_type: string }[] = [];

			for (const item of dndItems) {
				switch (item.id) {
					case 'username':
						currentItemState.username = item.value;
						break;
					case 'password':
						currentItemState.password = item.value;
						break;
					case 'url':
						currentItemState.url = item.value;
						break;
					case 'notes':
						currentItemState.notes = item.value;
						break;
					default:
						newCustomFields.push({ name: item.name, value: item.value, field_type: item.type });
						break;
			}
		}
		currentItemState.custom_fields = newCustomFields;
		currentItemState.field_order = dndItems.map((item) => item.id);

		// Normalize transient edit-state differences so clicking "Modify" alone
		// does not trigger the Unsaved Changes popup.
		const normalizedCurrent = JSON.parse(JSON.stringify(currentItemState));
		const normalizedOriginal = JSON.parse(JSON.stringify(originalPasswordItem));
		// Treat empty password during edit as placeholder 'N/A'
		if (normalizedCurrent.password === '') normalizedCurrent.password = 'N/A';
		if (normalizedOriginal.password == null) normalizedOriginal.password = 'N/A';
		// Treat empty URL as null (same as save normalization)
		if (normalizedCurrent.url === '') normalizedCurrent.url = null;

		hasUnsavedChanges = JSON.stringify(normalizedCurrent) !== JSON.stringify(normalizedOriginal);
	// Also consider pending tag changes
	if (!hasUnsavedChanges) {
		const origTags = (originalPasswordItem?.tags ?? '') as string;
		if (pendingTagOrder !== null && pendingTagOrder !== origTags) {
			hasUnsavedChanges = true;
		}
	}
	} else {
		hasUnsavedChanges = false;
	}
	}

function enterEditMode() {
	originalPasswordItem = JSON.parse(JSON.stringify(selectedPasswordItem));
	dndItems = [...displayFields];
	// If password is placeholder "N/A", clear it for editing
	for (const item of dndItems) {
		if (item.id === 'password' && (item.value === 'N/A' || item.value == null)) {
			item.value = '';
		}
	}
    pendingTagOrder = null;
	isEditing = true;
}

async function handleSave() {
    if (!selectedPasswordItem) return;
    const item = selectedPasswordItem as PasswordItem;

    const updated = JSON.parse(JSON.stringify(selectedPasswordItem));
    const newCustomFields: { name: string; value: string; field_type: string }[] = [];
    for (const item of dndItems) {
        const val = (item.value ?? '').toString().trim();
        switch (item.id) {
            case 'username':
                updated.username = val.length > 0 ? val : null;
                break;
            case 'password':
                updated.password = val.length > 0 ? val : 'N/A';
                break;
            case 'url': {
                if (val.length === 0) {
                    updated.url = null;
                } else {
                    // Ensure URL passes backend validation
                    updated.url = (/^https?:\/\//i.test(val) ? val : `https://${val}`);
                }
                break;
            }
            case 'notes':
                updated.notes = val.length > 0 ? val : null;
                break;
            default:
                newCustomFields.push({ name: item.name, value: item.value, field_type: item.type });
                break;
        }
    }
    updated.custom_fields = newCustomFields;
    updated.field_order = dndItems.map((item) => item.id);

    if (JSON.stringify(updated) !== JSON.stringify(originalPasswordItem)) {
        try {
            await invoke('update_password_item', { item: updated });
            // sync local state with saved version and baseline
            selectedPasswordItem = updated;
            originalPasswordItem = JSON.parse(JSON.stringify(updated));
        } catch (error) {
            console.error('Error updating password item:', error);
            alert(`Failed to save changes: ${error}`);
            return; // stay in edit mode to correct
        }
    } else {
        // no field changes, continue to check tag reorder below
    }

    // Apply pending tag reorder only on Save
    // Note: allow empty string ('') to clear all tags
    if (pendingTagOrder !== null && pendingTagOrder !== (item.tags ?? '')) {
        try {
            await invoke('update_password_item_tags', { id: item.id, tags: pendingTagOrder });
            const updatedItem = { ...item, tags: pendingTagOrder } as any;
            selectedPasswordItem = updatedItem;
            dispatch('tagsSaved', { id: updatedItem.id, tags: pendingTagOrder });
        } catch (error) {
            console.error('Error saving tag order:', error);
            alert(`Failed to save tag order: ${error}`);
            return; // stay in edit mode if tag save fails
        }
    }

    // Exit edit mode after a short delay so color transitions
    // in the edit view can play before the DOM branch swaps.
    hasUnsavedChanges = false;
    pendingTagOrder = null;
    await tick();
    setTimeout(() => { isEditing = false; }, 320);
}

	function handleReset() {
		if (originalPasswordItem) {
			selectedPasswordItem = JSON.parse(JSON.stringify(originalPasswordItem));
		}
		isEditing = false;
		hasUnsavedChanges = false;
		pendingTagOrder = null;
	}

	

	

	function formatTimestamp(timestamp: string | null): string {
		if (!timestamp) return 'N/A';
		const date = new Date(timestamp);
		return date.toLocaleString();
	}

	function handleCancelAddField() {
		addingField = false;
		newFieldName = '';
		newFieldType = 'text';
	}

	async function handleConfirmAddField() {
		if (!newFieldName.trim()) {
			alert('Please enter a name for the new field.');
			return;
		}

		if (selectedPasswordItem) {
			try {
				await invoke('add_custom_field', {
					itemId: selectedPasswordItem.id,
					fieldName: newFieldName,
					fieldType: newFieldType
				});
				alert('Custom field added successfully!');
				handleCancelAddField();
			} catch (error) {
				console.error('Error adding custom field:', error);
				alert(`Failed to add custom field: ${error}`);
			}
		}
	}
</script>

<main class="passwordDetail" class:editing={isEditing}>
	{#if selectedPasswordItem}
